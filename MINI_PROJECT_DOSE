#include"types.h"

void delay_us(u32 tdly)
{
	tdly *= 12;
	
	while(tdly--);
}
void delay_ms(u32 tdly)
{
	tdly *= 12000;
	
	while(tdly--);
}
void delay_s(u32 tdly)
{
	tdly *= 12000000;
	
	while(tdly--);
}

#include"types.h"

void delay_us(u32);
void delay_ms(u32);
void delay_s(u32);

#include<LPC21XX.h>
#include"types.h"
#include"keypad_defines.h"

void keypad_init(void)
{
	IODIR1 |= (1<<R0)|(1<<R1)|(1<<R2)|(1<<R3);
}

int stat_key(void)
{
	if(((IOPIN1>>C0)&0xf)== 0x0f)
	{
		return 1;
	}
	return 0;
}

char keypad_data(void)
{
	s8 rowval,colval;
	
	IOCLR1 = 1<<R0;
	IOSET1 = (1<<R1)|(1<<R2)|(1<<R3);
	if(((IOPIN1>>C0) & 0xf) != 0xf)
	{
		rowval = 0;
		 goto colcheak;
	}
	
	IOCLR1 = 1<<R1;
	IOSET1 = (1<<R0)|(1<<R2)|(1<<R3);
	if(((IOPIN1 >> C0) &0xf) != 0xf)
	{
		rowval = 1;
		goto colcheak;
	}
	
	IOCLR1 = 1<<R2;
	IOSET1 = (1<<R0)|(1<<R1)|(1<<R3);
	if(((IOPIN1 >> C0) & 0xf) != 0xf)
	{
		rowval = 2;
		goto colcheak;
	}
	IOCLR1 = 1<<R3;
	IOSET1 = (1<<R0)|(1<<R1)|(1<<R2);
	if(((IOPIN1 >> C0) & 0xf) != 0xf)
	{
		rowval = 3;
		
		goto colcheak;
	}
	
	colcheak:
		if(((IOPIN1 >> C0) & 1) == 0)
		{
			colval = 0;
		}
		else if(((IOPIN1 >> C1) & 1) == 0)
		{
			colval = 1;
		}
		else if(((IOPIN1 >> C2) & 1) == 0)
		{
			colval = 2;
		}
		else
		{
			colval = 3;
		}
		
		while(((IOPIN1 >> C0) & 0xf) != 0xf);
		
		return LUT[rowval][colval];
}

void keypad_init(void);
int stat_key(void);
char keypad_data(void);

#include"types.h"

s8 LUT[][4]={'7','8','9','<',
						 '4','5','6','>',	
						 '1','2','3','U',
					   '%','0','#','D'};
#define R0 16
#define R1 17
#define R2 18
#define R3 19
#define C0 20
#define C1 21
#define C2 22
#define C3 23

#include<LPC21xx.h>
#include"types.h"
#include"delay_header.h"
#include"defines.h"
#include"lcd.h"
#include"lcd_defines.h"

void lcd_init(void)
{
	IODIR0 |= (0xff<<LCD_DATA)|(1<<RS)|(1<<RW)|(1<<EN);
	delay_ms(20);
	lcd_cmd(0x30);//8 bit mode
	delay_ms(8);
	lcd_cmd(0x30);//8 bit mode
	delay_ms(1);
	lcd_cmd(0x30);//8 bit mode
	delay_ms(1);
	lcd_cmd(0x38);//8 bit mode with 5*7 font
	lcd_cmd(0x10);// lcd off
	lcd_cmd(0x01);//clear
	lcd_cmd(0x06);//cursor auto point to next
	lcd_cmd(0x0c);// blinking cursor;
	lcd_cmd(GOTO_LINE_1_POS_0);
}

void lcd_disp(u8 data)
{
	IOCLR0 = 1<<RW;
	WRITEBYTE(IOPIN0,LCD_DATA,data);
	IOSET0 = 1<<EN;
	delay_us(1);
	IOCLR0 = 1<<EN;
	delay_ms(2);
}

void lcd_cmd(u8 cmd)
{
	IOCLR0 = 1<<RS;
	lcd_disp(cmd);
}

void lcd_char(s8 data)
{
	IOSET0 = 1<<RS;
	lcd_disp(data);
}

void lcd_str(s8 *ptr)
{
	while(*ptr)
	{
	 lcd_char(*ptr++);
	}
}

void lcd_int(s32 num)
{
	s8 i =0,arr[10];
	
	if(num == 0)
	{
		lcd_char(0 + 48);
	}
	else
	{
		if(num  < 0)
		{
			lcd_char('-');
			num = -num;
		}
		while(num)
		{
			arr[i++] = num % 10 + 48;
			num/=10;
		}
		i--;
		
		for(; i >= 0 ;i--)
		{
			lcd_char(arr[i]);
		}
	}
}
	
void lcd_f32(f32 num , u32 nDP)
{
		u32 n,i;
		
		if(num < 0)
		{
			lcd_char('-');
			num = -num;
		}
		n = num;
		lcd_int(n);
		lcd_char('.');
		 
		for(i = 0 ;i < nDP ;i++)
		{
			num = (num - n) *10;
			n = num;
			lcd_char(n+48);
		}
}

void WriteToCGRAM(s8 *a)
{
	s8 i;
	lcd_cmd(0x40);//Cur is placed at CGRAM loc
	for(i=0;i<8;i++)
		lcd_char(a[i]);
}


#include"types.h"

void lcd_init(void);
void lcd_cmd(u8 cmd);
void lcd_char(s8 data);
void lcd_str(s8 *);
void lcd_int(s32 num);
void lcd_f32(f32 num , u32 nDP);
void WriteToCGRAM(s8 *a);


#define LCD_DATA 0
#define RS 8
#define RW 9
#define EN 10

#define GOTO_LINE_1_POS_0 0x80
#define GOTO_LINE_2_POS_0 0xc0

#define LCD_CLR 0x01
